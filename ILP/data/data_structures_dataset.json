{
  "statements": [
    {
      "id": 0,
      "text": "Binary search trees and balanced binary search trees both rely on ordered structure to guarantee O(log n) search performance."
    },
    {
      "id": 1,
      "text": "Hash tables outperform linked lists in average lookup time, but they require collision-handling techniques like chaining or open addressing."
    },
    {
      "id": 2,
      "text": "A min-heap enables efficient priority queue operations, such as insert and delete-min, all maintained in O(log n) time."
    },
    {
      "id": 3,
      "text": "Depth-first search uses a stack, often implicitly through recursion, to explore graphs along long paths before backtracking."
    },
    {
      "id": 4,
      "text": "Breadth-first search relies on a queue to traverse graph nodes level by level, making it ideal for shortest-path discovery in unweighted graphs."
    },
    {
      "id": 5,
      "text": "Binary search requires a sorted array, and although access is constant time, inserting into the same array may require shifting many elements."
    },
    {
      "id": 6,
      "text": "Balanced binary search trees avoid the worst-case degeneration to linked lists that unbalanced structures can suffer."
    },
    {
      "id": 7,
      "text": "A heap supports priority queue operations by bubbling elements up or down to maintain its tree-ordered property."
    },
    {
      "id": 8,
      "text": "Graphs represented by adjacency lists save memory on sparse networks, while adjacency matrices simplify constant-time edge checks."
    },
    {
      "id": 9,
      "text": "Dijkstra's algorithm uses a priority queue, often backed by a min-heap, to repeatedly extract the next closest vertex."
    },
    {
      "id": 10,
      "text": "Merge sort guarantees O(n log n) time regardless of input, unlike quick sort which risks O(n²) when pivot choices are poor."
    },
    {
      "id": 11,
      "text": "Stacks and queues both manage ordered collections, but stacks follow LIFO semantics while queues operate under FIFO rules."
    },
    {
      "id": 12,
      "text": "Hash tables can degrade to linear-time lookup when collisions accumulate, especially compared to the predictable performance of balanced binary search trees."
    },
    {
      "id": 13,
      "text": "Graph traversal algorithms such as depth-first search and breadth-first search differ mainly in their underlying data structures—stacks for depth-first, queues for breadth-first."
    },
    {
      "id": 14,
      "text": "Quick sort and merge sort both rely on divide-and-conquer, but only merge sort guarantees stable sorting."
    },
    {
      "id": 15,
      "text": "Using adjacency lists or adjacency matrices influences the efficiency of algorithms like Dijkstra's, BFS, and DFS, depending on graph density."
    }
  ],
  "entities": [
    { "id": 0, "name": "binary search tree" },
    { "id": 1, "name": "balanced binary search tree" },
    { "id": 2, "name": "O(log n)" },
    { "id": 3, "name": "search performance" },
    { "id": 4, "name": "hash table" },
    { "id": 5, "name": "linked list" },
    { "id": 6, "name": "chaining" },
    { "id": 7, "name": "open addressing" },
    { "id": 8, "name": "hash collisions" },
    { "id": 9, "name": "min-heap" },
    { "id": 10, "name": "priority queue" },
    { "id": 11, "name": "insert" },
    { "id": 12, "name": "delete-min" },
    { "id": 13, "name": "depth-first search" },
    { "id": 14, "name": "stack" },
    { "id": 15, "name": "recursion" },
    { "id": 16, "name": "graph" },
    { "id": 17, "name": "breadth-first search" },
    { "id": 18, "name": "queue" },
    { "id": 19, "name": "shortest path" },
    { "id": 20, "name": "binary search" },
    { "id": 21, "name": "array" },
    { "id": 22, "name": "constant time" },
    { "id": 23, "name": "heap" },
    { "id": 24, "name": "adjacency list" },
    { "id": 25, "name": "adjacency matrix" },
    { "id": 26, "name": "Dijkstra's algorithm" },
    { "id": 27, "name": "merge sort" },
    { "id": 28, "name": "quick sort" },
    { "id": 29, "name": "O(n log n)" },
    { "id": 30, "name": "O(n^2)" },
    { "id": 31, "name": "LIFO" },
    { "id": 32, "name": "FIFO" }
  ],
  "entity_statements": {
    "0":  [0],
    "1":  [0, 6, 12],
    "2":  [0, 2],
    "3":  [0],
    "4":  [1, 12],
    "5":  [1, 6],
    "6":  [1],
    "7":  [1],
    "8":  [1, 12],
    "9":  [2, 9],
    "10": [2, 7, 9],
    "11": [2],
    "12": [2],
    "13": [3, 13, 15],
    "14": [3, 11, 13],
    "15": [3],
    "16": [3, 4, 8, 13, 15],
    "17": [4, 13, 15],
    "18": [4, 9, 11],
    "19": [4],
    "20": [5],
    "21": [5],
    "22": [5, 8],
    "23": [7],
    "24": [8, 15],
    "25": [8, 15],
    "26": [9, 15],
    "27": [10, 14],
    "28": [10, 14],
    "29": [10],
    "30": [10],
    "31": [11],
    "32": [11]
  }
}
